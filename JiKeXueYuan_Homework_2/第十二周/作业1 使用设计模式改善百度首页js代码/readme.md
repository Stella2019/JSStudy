**本次作业是基于之前使用fis3重构百度首页的基础上做的优化，因此关于fis3的部署，还请看考下面的“关于作业说明”章节。**  
**对于本次作业的设计模式的说明，请参考“使用到的设计模式“章节。**

##使用设计模式优化百度首页代码
本次作业是使用设计模式优化现有的js代码。
感觉平时用到了很多设计模式，只是自己没有意识到是设计模式。

###使用到的设计模式
1. 单例模式  
    项目中使用了jQuery，jQuery的$本身就是一个单例。
    
    好处：$即jQuery，jQuery即$。无论在哪里使用，$都代表着唯一的一个jQuery对象。jQuery好像是加载时创建的，即引用了jQuery文件，jQuery就存在。
    有的单例则通过一个标志位，或者自身的引用变量来指示自己是否已经被创建，通常的做法是如果自己存在则返回自己，自己不存在则创建自己。这样的好处是，在用到的时候才创建，节约使用内存。
    
    缺点：我理解设计模式的优点和缺点都是依赖使用的场景。也就是缺点可能是由于使用不当造成的，而不是该设计模式本身的缺陷。
    单例模式可以有效保证引用的对象的唯一，但是如果到处被使用则会增加了该对象与业务的耦合性，即该对象一旦修改，则会影响到所有使用该单例对象的业务。
    jQuery单例的一个可能的问题是，命名冲突，如果有个库也使用了$会导致命名冲突，（jQuery自身提供了解决命名冲突的方式）。
    
2. 简单工厂，单例模式
    体现代码：dev/index/tool_theme/tool_theme.js (当前项目中dev/index下的模块均为单例模式，这里tool_theme.js作为一个例子) 
    项目中使用了seajs的require，对于require本身是一个工厂模式，通过字符串来得到想要的对象。
    我在项目中使用require的目的是得到组成一个页面中某个模块，而这个模块在页面中是唯一的，所以在这个项目中通过require得到的对象是一个单例对象。因此这块使用的是工厂和单例的组合。
    （如果是一个通用模块，需要在页面中多次引用，并每个引用都维护自己的状态，则不建议做成单例，如即可学院首页的滑动窗口）。
    
    好处：通过工厂模式创建的对象都指向了一个唯一的模块。
    无论在项目中的哪里，创建和使用该对象，都指向了唯一的一个对象，该对象可以有多个引用，不会造成命名冲突，使用的前提是需要对模块名称提前进行规划。
    
3. 通知者模式  
    体现代码：dev/index/tool_theme/tool_theme.js
    百度首页有个功能可以改变外观，改变涉及到中间的搜索框的logo，个人定制的框的透明度，全局背景。
    这里使用的是通知者模式，因为中间搜索框，个人定制框都属于不同的模块，因此通过使用通知者模式来作为模块间的通信。
    实现思路是在主题模块中，增加观察者列表，然后在上层的初始化中，通过主题模块提供的接口，将需要的观察者添加到该列表中，然后在主题变更时执行观察者列表中的函数。
    
    好处：模块间不直接相互调用，而是通过有限的接口实现相互通信。降低了模块间的耦合性。
    模块间并不需要关心对方模块都做了什么，甚至都不需要关心所通知的是什么模块，实现了模块间的松耦合。
    通知方式可以是多种，也可以使用事件系统，即通过事件模块来代理，这样就是通知者模式和代理模式的组合。
    也可以在模块内部完成通知。无论哪种方式都需要事先约定通知的接口。
    
    缺点：通知者或者通知的代理者一直会保存着被通知者的引用，导致被通知者将一直存在内存中，不能被垃圾回收，所以在被通知者的内存管理上要注意销毁时同时取消通知。
    
4. 外观模式  
    体现代码：dev/index/main.js  
    其实这个模式使用的比较普遍。在当前这个项目中，由于页面中每个部分都相对独立，有关系的模块也通过观察者模式进行通信。
    对于上层调用者来说，只需要将这个模块渲染在页面上即可。因此，模块只需要对外提供render接口即可，剩下的事件绑定，用户交互等都在模块内部完成。
    所以，在dev/index/main.js中只要将各个模块渲染，并更新主题就可以了，剩下的逻辑均在模块内部执行。
    
    好处:将对外不关心的逻辑分装起来，对外提供一个有意义的，并且简单的接口。使得调用层更聚焦在业务，而不用关心业务的逻辑。 
    
##开发环境
###软件版本
|软件|操作系统|nodejs|fis|
|---|---|---|---|---|
|版本|OS X 10.11.2|v4.2.3|v3.3.13|

###所需要的依赖：
1. fis-optimizer-html-minifier
2. fis3-hook-cmd
3. fis3-postpackager-loader

##关于作业说明
基本的思路是，将项目的文件分为静态资源和页面资源。（本来应该把seajs依赖的html代码也搞成静态资源，但这样做就只剩一个index页面了，太少了，为了练习就把依赖的html也做为页面处理啦）
‘moreVideodata.html’是一个特殊情况，这个文件是模拟ajax返回json数据的。所以这个文件就当做单另的处理了。
源文件结构：
```
root
|-index                 //由于index页面也是模块化的，使用到的组成页面的模块都存在这里
|-module                //保存了可以公共的模块
|-seajs                 //seajs相关文件
|-node_modules          //nodejs模块和依赖
|-index.html            //首页
|-moreVideodata.html    //ajax数据模拟
|-package.json          //nodejs配置信息
|-fis-conf.js           //fis项目流程配置
```
导出的目录是按照如下规则导出：
```
root
|-version               //这个版本也可以去掉，我理解依据具体的项目情况来设置。
   |-js                 //所有的js文件
   |-css                //所有的CSS文件
   |-htmls              //所有的html文件
   |-images             //所有的图片文件
   |-index.html         //首页
   |-moreVideodata.html //ajax数据模拟
```
所有的静态文件均打上了hash码，包括JS，CSS，图像文件。
所有的CSS和JS文件均进行了压缩操作。

部署的建议采用releas命令输出到自己希望的文件夹下。如：
```
fis3 release -d ../dist
```  
将输出的文件夹作为网站的根目录，按照上面的例子请将dist文件夹作为网站根目录。然后访问下面的链接即可：
```
http://[your server ip]/[version in your fis config file]/
```
示例:在我的机器上是：
```
http://127.0.0.1/1.0.0/index.html
```
编译部署后的代码可以正常运行，除了'moreVideodata.html'中的资源外，应该没有404问题。
**本次作业除了对在JS中的静态资源设置了__uri()，和将index.html中的seajs.config移到了fis-config中，其他的代码均未做修改。**